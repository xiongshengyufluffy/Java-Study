# 1.为什么需要消息队列？哪些问题适用消息队列解决？

- 原因: 解决上下游生产速度不一致的问题
- 适用问题:
  - **1. 异步处理**
  
    - 优点
      - 可以更快地返回结果
      - 减少等待，自然实现了步骤之间的并发，提升系统总体的性能。   
  - **2. 流量控制**
    - 使用消息队列隔离网关和后台服务
  - **3. 消息队列的另外一个作用，就是实现系统应用之间的解耦**
    - 系统A下游的系统都需要实时获得来自于系统A的数据
    - 如果不使用消息队列:
      - 随着下游系统的增加,如果下游系统接口发生变更,需要修改系统A,重新上线
    - 引入消息队列:
      - 系统A在数据状态发生变更时,发送一条消息到主题Order上去,所有下游系统订阅主题后,都可以获得一份实时、完整的数据
      - 无论增加、减少下游系统或是下游系统需求如何变化，系统A提供的服务都无需做任何更改，实现了上下游服务的解耦。
   
- 优点:
  - 1.可在模块、服务、接口等不同粒度上实现解耦
  - 2.订阅/消费模式也可在数据粒度上解耦
  - 3.可提高系统的并发能力，集中力量办大事(同步部分)，碎片时间做小事(异步部分)  
  - 4.可提高系统可用性，因为缓冲了系统负载

- 缺点:
  - 1.降低了数据一致性，如要保持强一致性，需要高代价的补偿(如分布式事务、**对账(必要采取的补偿机制)**)
  - 2.有数据丢失风险，如宕机重启，如要保证队列数据可用，需要额外机制保证(如双活容灾)

## 必券为了保证数据的强一致性采取的补偿机制
- 将数据添加到缓存/数据库时,如果发生异常,将异常信息插入异常表
- 使用定时任务扫描异常表进行补偿

# 2.消息模型:主题和队列的区别
## 主题和队列的区别
消息队列的模型可以分为 队列模型(早期) 和 主题-订阅模型
### 队列模型

**早期的消息队列，就是按照“队列”的数据结构来设计的**
- 生产者（Producer）发消息就是入队操作
- 消费者（Consumer）收消息就是出队也就是删除操作
- 服务端存放消息的容器自然就称为“队列”。这就是最初的一种消息模型：队列模型。

![](https://gitee.com/fluffyball/blogimage/raw/master/images/localPC/202109032139159.png)

如果有多个生产者往同一个队列里面发送消息，这个队列中可以消费到的消息，就是这些生产者生产的所有消息的合集。消息的顺序就是这些生产者发送消息的自然顺序。


如果有多个消费者接收同一个队列的消息，这些消费者之间实际上是竞争的关系，每个消费者只能收到队列中的一部分消息，也就是说任何一条消息只能被其中的一个消费者收到。


如果需要将一份消息数据分发给多个消费者，要求每个消费者都能收到全量的消息，例如，对于一份订单数据，风控系统、分析系统、支付系统等都需要接收消息。这个时候，单个队列就满足不了需求，**一个可行的解决方式是，为每个消费者创建一个单独的队列，让生产者发送多份**。

缺点: 

- 同样的一份消息数据被复制到多个队列中会浪费资源，更重要的是，生产者必须知道有多少个消费者。
- 为每个消费者单独发送一份消息，这实际上违背了消息队列“**解耦**”这个设计初衷。

**“发布 - 订阅模型（Publish-Subscribe Pattern）”**

![](https://gitee.com/fluffyball/blogimage/raw/master/images/localPC/202109032153779.png)
- 消息的发送方称为发布者（Publisher）
- 消息的接收方称为订阅者（Subscriber）
- 服务端存放消息的容器称为主题（Topic）

- 行为
  - 消息发送: 发布者将消息发送到主题中
  - 订阅主题: 订阅者在接收消息之前需要先"订阅主题"
    - “订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本
    - 每份订阅中，订阅者都可以接收到主题的所有消息。

**相同点/不同点**
  - 一份消息数据能不能被消费多次
    - 如果只有一个订阅者，那它和队列模型就基本是一样的了
    - 也就是说，发布 - 订阅模型在功能层面上是可以兼容队列模型的

## Rocketmq的消息模型
### 请求-确认机制
#### 生产端-服务端(broker)交互
在生产端，生产者先将消息发送给服务端，也就是 Broker。

服务端在收到消息并将消息写入主题或者队列中后，会给生产者发送确认的响应。

如果生产者没有收到服务端的确认或者收到失败的响应，则会重新发送消息；

#### 服务端(broker)-消费端交互
服务端给消费端发送消息

在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认。


服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认


### 请求-确认机制
#### 优点
确认机制很好地保证了消息传递过程中的**可靠性**

#### 缺点
采取**请求-确认机制**保障有序性会带来较大的开销
- 保障有序性:某一条消息被成功消费之前、下一条消息是不能被消费的

为了保证**有序性**
- 某一条消息被成功消费之前、下一条消息是不能被消费的
- 即:每个主题在任意时刻,至多只能有一个消费者实例在进行消费,无法通过水平扩展消费者的数量来提升消费端总体的消费性能。
- 为了解决这个问题,RocketMQ在主题下增加了**队列**的概念

### rocketMQ消息发送模型
![](https://gitee.com/fluffyball/blogimage/raw/master/images/localPC/202109041128928.png)

- 有序性: 
  - **每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费**，rocketMQ只在**队列**层面上保证消息的有序性,**主题层面**无法保证消息的有序性。
- 消费:
  - 不同的消费者$\rightarrow$不同的消费组(Consumer Group)
    - **每个消费组**消费主题中一份完整消息
      - **不同消费组之间的消费进度互相不受影响**
      - **相同消费者组之间的消费进度是竞争关系**
- **消费位置**:
  - 由于消息需要被**不同的组进行多次消费，所以消费完的消息并不会立即被删除**,因此rocketMQ为每个消费组在每个队列上**维护一个消费位置（Consumer Offset)**.
    - 该位置之前的消息都被消费过
    - 该位置之后的消息都没有被消费过
    - 每消费成功一条消息,消费位置+1

### 小结
- 1、主题（topic）中有多个队列（队列数量可以水平进行扩容），生产者将其消息发送给主题中的某个队列（根据一定的路由规则，比如取模之类的），主题不保证消息的有序，只有队列中的消息才是有序的。
  

- 2、从主题中的所有队列中取出消息给所有消费组进行消费，消息只能被消费组中的一个线程进行消费，有点类似线程池的形式，工作线程消费来自不同队列的消息，感觉这也是RocketMq,低时延的原因，不同队列中的消息可以同时被消费，并且消费组的线程也可以并发的消费不同的消息。
- 3、由于主题中的一个队列都会被多个消费组进行消费，为此需要为每个消费组的消费的不同队列为此一个下标(每个消费组可以一直消费队列中的消息，无需等待其他消费组的确认)，主题中的队列消息是有序的，为此需要等到所有消费组对此条消息进行确认，才能从队列中移除(消息的可能删除时机)。感觉每个消费组的队列下标，可以一个队列维护一个CurrentHashMap来为此每个消费组的下标，这样的话可以防止锁的竞争。
- 思考题:在消费的时候，为了保证消息的不丢失和严格顺序，每个队列只能串行消费，无法做到并发，否则会出现消费空洞的问题。那**如果放宽一下限制，不要求严格顺序，能否做到单个队列的并行消费呢？如果可以，该如何实现**？
- 尝试回答下课后习题，感觉队列可以维护一个全局的下标，消费队列时，使用CAS进行下标的获取，由于不保证消息消费的有序，这样的话可以并发的消费消息，由于有全局下标，不会出现获取队列的空洞消息。

# 3.如何例用事务消息实现分布式事务
## 消息队列中的"事务"
- **消息队列需要"事务"的原因**,是**因为**我们“发消息”这个过程，目的往往是通知另外一个系统或者模块去更新数据
- **消息队列依赖"事务",为了解决**消息生产者和消息消费者的数据一致性问题
- **事务需要解决的问题,举个栗子来说**,eg:**卡券状态变更** 和 **发送消息** 要么都成功、要么都操作失败、不允许一个成功而另外一个失败的情况

## 消息队列如何实现分布式事务

### rocketMQ实现分布式事务-主要原理
![](https://gitee.com/fluffyball/blogimage/raw/master/images/localPC/202109041534260.png)

- 订单系统给购物车系统发送一条消息
  - (1)订单系统在消息队列上开启一个事务、然后订单系统给消息服务器发送一个**半消息**
  - 半消息消息内容完整
  - 但是,在**事务提交之前**,半消息的内容对消费者不可见
  - (2)订单系统执行本地事务
    - **如果本地事务成功**,提交事务消息,购物车系统消费这条消息,继续后面的流程
    - **如果本地事务失败**,回滚事务消息,购物车系统就不会收到这条消息
  
### 可能的问题以及反查机制
- 如果在**第四步提交事务消息时失败了**怎么办？
- rocketMQ增加了事务反查机制来解决事务消息提交失败的问题
- 订单系统(Producer)
  - 1.开启事务
  - 2.发送半消息
  - 3.执行本地事务、创建订单
  - 4.**提交或回滚失败** $\rightarrow$ Broker没有收到提交或者回滚的请求
    - **Broker**会定期去订单系统(Producer)上反查这个事务对应本地事务的状态,然后根据反查结果决定**提交**或者**回滚**这个事务
    - 我们的业务代码需要**实现一个反查本地事务状态的接口**，告知 RocketMQ 本地事务是成功还是失败
    - 在我们这个例子中，反查本地事务的逻辑也很简单，我们只要根据消息中的订单 ID，在订单库中查询这个订单是否存在即可，如果订单存在则返回成功，否则返回失败
  
### 必券反查接口
- 背景:营销活动时不同的批次下发的卡的类型、批次, 需要消费【活动中心】的MQ,获得本次活动的卡的类型和批次信息。
- 消费mq,获得cardType,cardBatchId
- 如果cardType 或者 cardBatchId为空
  - 打印日志
  - return
- 校验cardType类型合法
- 根据cardBatchId查本地数据库,如果查到不为空**反查本地事务**
  - 打印日志,批次已经存在 + cardBatchId
  - 返回
- 调用【活动中心】的RPC接口查询
- 如果查询结果为空
  - 打印日志,从活动中心查询批次信息失败 + 批次号
  - 返回
- 此时,查询结果不为空
  - 组装记录
  - 插入本地数据库
  - 将查询结果添加到缓存中