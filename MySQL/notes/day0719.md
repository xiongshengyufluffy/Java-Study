# 输入输出模板

![20210808202444](https://i.loli.net/2021/08/08/AralY3mjftw5OLG.png)
# 三数之和

- 题解

![20210719214859](https://xiongshengyu-1256692535.cos.ap-beijing.myqcloud.com/photos/20210719214859.png)

```Java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int length = nums.length;
        if(length < 3) return new ArrayList<>();
        // 1.排序
        Arrays.sort(nums);
        
        // i [i + 1, n - 1] left == i + 1 < n
        List<List<Integer>> results = new ArrayList<>();
        for(int i = 0; i < length - 2; i++){
            int left = i + 1, right = length - 1;
            if(i > 0 && nums[i] == nums[i - 1]) continue;
            while(left < right){
                int curThreeSum = nums[i] + nums[left] + nums[right];
                if(curThreeSum < 0){
                    left++;
                }else if(curThreeSum > 0){
                    right--;
                }else{ // left < right && curThreeSum == 0
                    // left 由 左侧的left 向右
                    if(left - 1 > i && nums[left] == nums[left - 1]) left++;
                    else if(right < length - 1 && nums[right] == nums[right + 1]) right--;
                    else{
                        List<Integer> result = new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right]));
                        left++;
                        right--;
                        results.add(result);
                    }
                    
                }
            }
        }
        
        return results;

    }
}
```
## Points
- 对于left,right重复情况的判断
  - 在满足nums[left] + nums[right] + nums[i] == 0,但是是属于重复情况,需要跳过时
    - left > i + 1(因为nums[i] == nums[left], 在left == i + 1时并不认为是重复情况)


# 直线上最多的点
![20210719222359](https://xiongshengyu-1256692535.cos.ap-beijing.myqcloud.com/photos/20210719222359.png)

- 求两个数字的公约数
- 字符串存储分子分母约分后面的结果

```Java
    class Solution {
        public int maxPoints(int[][] p) {
            if(p.length <= 1) return 1;

            // 从points[i] --> points[j]的斜率
            int maxValue = 1;
            for(int i = 0; i < p.length; i++){ 
                Map<String, Integer> map = new HashMap<>();
                for(int j = i + 1; j < p.length; j++){
                    int deltaX = p[i][0] - p[j][0];
                    int deltaY = p[i][1] - p[j][1];
                    int k = gcd(deltaX, deltaY);
                    String key = deltaX / k + "/" + deltaY / k;
                    map.put(key, map.getOrDefault(key, 0) + 1);
                    maxValue = Math.max(maxValue, map.get(key));
                }
            }

            return maxValue + 1;
        }

        static int gcd(int a, int b){
            if(b == 0) return a;
            return gcd(b, a % b);


        }
    }
```
## Points
- gcd写法
- 点.length <= 1特判
- 每当遍历到达一个点时,使用一个新的map来记录当前点出发的斜率相同次数, 共线点数 == 相同斜率数 + 1


# 最小窗口子序列
- 参考解法DP
  - https://leetcode-cn.com/problems/minimum-window-subsequence/solution/dong-tai-gui-hua-by-matrix95/
  - https://leetcode-cn.com/problems/minimum-window-subsequence/solution/du-chuang-zai-zi-fu-pi-pei-biao-zhong-xun-zhao-zui/

![20210720214156](https://xiongshengyu-1256692535.cos.ap-beijing.myqcloud.com/photos/20210720214156.png)


- 参考解法滑窗

```Java
class Solution {
    static char[] ss1;
    static char[] ss2;
    // ss1的长度 >= ss2
    public String minWindow(String s1, String s2) {
        // 校验ss1,ss2的长度
        if(s1.isEmpty() || s2.isEmpty()) return "";
        if(s2.length() > s1.length()) return "";
        
        ss1 = s1.toCharArray();
        ss2 = s2.toCharArray();
        // System.out.println(Arrays.toString(ss1));
        int minLength = ss1.length + 1; // 最短子字符串长度
        int mStart = -1, mEnd = -1; // 最短子字符串对应的起始位置,终止位置
        
        int rStart = 0;// 向右出发的开始位置
        boolean isContains = true; // s1是否包含s2
        while(true){
            int rEnd = goRight(rStart); // 向右出发的结束位置
            if(rStart == 0 && rEnd == -1){ // 第一次向右出发查找失败,s1不包含s2
                isContains = false;
                break;
            }
            if(rEnd == -1) break;
            
            int rLength = rEnd - rStart; // 向右匹配的长度
            // System.out.println(rStart + "-->" + (rEnd - 1) + "length: " + rLength);
            
            int lStart = rEnd - 1; // 向左出发的开始位置
            int lEnd = goLeft(lStart);
            
            int lLength = lStart - lEnd;
            // System.out.println((lEnd + 1) + "<--" + (lStart) + "length: " + lLength);

            if(rLength == lLength && lLength < minLength){
                mStart = rStart;
                mEnd = rEnd;
                minLength = lLength;
            }
            else if(rLength > lLength && lLength < minLength){
                mStart = lEnd + 1;
                mEnd = lStart + 1; // 范围左闭右开
                minLength = lLength;
            }
            // System.out.println("minLength: " + minLength + 
            //                    "mStart: " + mStart + 
            //                   "mEnd: " + mEnd);

            if(rLength == lLength){
                rStart = rStart + 1; // 易错
            }else if(rLength > lLength){
                rStart = lEnd + 1;
            }
        }
        if(!isContains || minLength == ss1.length + 1) return "";
        return s1.substring(mStart, mEnd);
    }
    
    // 从ss1的start位置出发,一直 → 匹配ss2,直到匹配ss2结束

    static int goRight(int start){
        int j = 0; // ss2的匹配位置
        int i = start;              
        while(i < ss1.length){
            if(ss1[i] == ss2[j]){
                j++;
            }
            i++;
            if(j >= ss2.length) break;
        }
       //  System.out.println(start + " " + i);
        if(j < ss2.length) return -1; // 匹配ss2失败
        return i;
    }
    
    // 从ss1的start位置出发, 一直 ← 匹配ss2,直到匹配ss2结束
      static int goLeft(int start){
        int j = ss2.length - 1; // ss2的匹配位置
        int i = start;
        while(i >= 0){
            if(ss1[i] == ss2[j]){
                j--;
            }
            i--;
            if(j < 0) break;
        }
        // 向左走匹配失败的情况应该不太可能 if(j >= 0)
        return i;
    }
    
    
}
```

## Points
- rStart = rStart + 1; // 易错
- 代表以下情况

![20210725215423](https://xiongshengyu-1256692535.cos.ap-beijing.myqcloud.com/photos/20210725215423.png)


# 最长连续序列
- 可以考虑并查集的**按秩合并**的思路:
  - 每次将树高较低的树合并到树高较高的树中
- 并查集的解法
  - 路径压缩 $O(logn)$
  - 按秩合并 $O(logn)$
  - 路径压缩 + 按秩合并 $O(1)$
- 本题类似于并查集的做法采用的是类似**并查集按秩合并**的思路

- 本题非并查集解法
  - 类似于递推公式
    - 先将数组中的所有元素用set存起来
    - 枚举到x时,检查x+1是否在set中,如果存在,检查x+2,...,一直枚举到y为止,此时以x开始的最长连续子序列长度为$y - x + 1$,这个过程可以称为**递推**
    - 这样如果逐一枚举x,时间复杂度还是较高
      - **优化**: 当枚举到x时,假如x-1在集合中,那么表明x不能作为序列的开头,则跳过当前x,换言之,只枚举连续子序列的最小值

```
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length == 0) return 0;
        
        Set<Integer> set = new HashSet<>();
        for(int num : nums){
            set.add(num);
        }
        int maxLength = 1;
        for(int num : nums){
            if(set.contains(num - 1)){
                continue;
            }
            // num是一段子序列的起点
            int numCopy = num;
            int curLength = 1;
            while(set.contains(numCopy + 1)){
                curLength += 1;
                maxLength = Math.max(maxLength, curLength);
                numCopy += 1;
            }
        }
        return maxLength;

    }
}
```

# 用两个栈实现队列
```
class MyQueue {
    Stack<Integer> stk1;
    Stack<Integer> stk2;
    /** Initialize your data structure here. */
    public MyQueue() {
        stk1 = new Stack<>();
        stk2 = new Stack<>();
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        stk1.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if(stk2.isEmpty()){
            while(!stk1.isEmpty()){
                int num = stk1.pop();
                stk2.push(num);
            } 
        }
        return stk2.pop();
    }
    
    /** Get the front element. */
    public int peek() {
        if(stk2.isEmpty()){
           while(!stk1.isEmpty()){
                int num = stk1.pop();
                stk2.push(num);
            } 
        } 
        return stk2.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return stk1.isEmpty() && stk2.isEmpty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

# 数组中第k个最大元素
- 三解法
## partition解法
```
  public int partition(int lo, int hi){
        int idx = (int)(lo + Math.random() * (hi - lo + 1));
        int pivot = arr[idx];
        swap(idx, lo);
        int j = lo;
        for(int i = lo; i < hi + 1; i++){
            if(arr[i] < pivot){
                j++;
                swap(j, i);
            }
        }
        swap(j, lo);
        return j;
    }
    
```

## Points
- Java中生成[lo, hi]的随机一个整数的方式
  - ```int idx = (int)(lo + Math.random() * (hi - lo + 1));```


## 小根堆解法

整体思路

数组中第k个最大元素,即建立[第k大, 第k-1大, 第k-2大,...第1大]的小根堆

- (1)前k个元素建成小根堆,小根堆的容量为k
- (2)剩下的元素和堆顶比较,如果大于堆顶
  - 蒋当前元素 和 堆顶元素**值交换**
  - **将堆顶下滤**
  - (<font color=red>**注意:堆顶元素对应的元素的下标是1,为什么值交换？为什么下滤**</font>)
    - 值交换是因为当前元素值 > 小根堆堆顶元素值,小根堆堆顶因为较小,此时不可能成为第k大元素
    - **下滤是因为需要维护小根堆的性质,root < leftChild and root < rightChild**,如果此时被取代后的堆是全数组最大值,那么真正较小的第k大元素永远没法放进来

todo:时间,空间复杂度分析

```Java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        MinHeap hp = new MinHeap(k);
        for(int i = 0; i < k; i++){
            hp.add(nums[i]);
        }
       // System.out.println("i:  " + Arrays.toString(hp.heapArr));
       // System.out.println(hp.heapArr[1]);
       // System.out.println(hp.length);
        for(int i = k; i < nums.length; i++){
            if(nums[i] > hp.peek()){
              hp.heapArr[1] = nums[i];
              hp.down(1);
             // System.out.println("i:  " + Arrays.toString(hp.heapArr));
            }
        }
        return hp.peek();
    }
    class MinHeap {
    int length; // 当前堆中的元素个数
    int[]  heapArr; // 用于模拟堆的数组
    static final int DEFAULT_CAP = 10_006; // 堆的默认容量
    MinHeap(){
        length = 0;
        heapArr = new int[DEFAULT_CAP];
    }
        
     MinHeap(int k){
        length = 0;
        heapArr = new int[k + 1];
    }



    // 下滤:如果父亲节点大于两个孩子,则父亲节点应该下滤,直到堆底
    /**
     * 待下滤的元素的坐标:
     * @param idx
     */
    public void down(int idx){
        int curMin = heapArr[idx]; // 三个节点的最小值
        int curMinIdx = idx; // 三个节点的最小值对应的点的下标

        int lChild = 2 * idx;
        int rChild = 2 * idx + 1;
        // length需要修改一下
        if(lChild <= length && heapArr[lChild] < curMin) {
            curMin = heapArr[lChild];
            curMinIdx = lChild;
        }
        if(rChild <= length && heapArr[rChild] < curMin) {
            curMin = heapArr[rChild];
            curMinIdx = rChild;
        }
        // 如果发生了交换,下滤curMinIdx
        if(curMinIdx != idx){
            swap(curMinIdx, idx);
            down(curMinIdx);
        }
    }

    // 上滤:如果孩子节点小于父亲节点,则应该上滤,直到堆顶
    public void up(int idx){
        if(idx == 1) return; // 易错
        int curMin = heapArr[idx]; // 三个节点的最小值
        int curMinIdx = idx; // 三个节点的最小值对应的点的下标

        int parent = idx / 2;
        if(parent !=  idx && curMin < heapArr[parent]){
            curMinIdx = parent;
        }
        if(curMinIdx != idx){
            swap(curMinIdx, idx);
            up(curMinIdx);
        }

    }

   
    public void swap(int x, int y){
        int temp = heapArr[x];
        heapArr[x] = heapArr[y];
        heapArr[y] = temp;
    }

    public void add(int num){
        length++;
        heapArr[length] = num;
        up(length); // 易错点
    }


    public void poll(){
        heapArr[1] = heapArr[length];
        length--;
        down(1);
    }

    public int peek(){
        return heapArr[1];
    }

    }
}

```

## Points
- down,up操作入参都是下标
- up操作,递归基的终点是```idx == 1```,因为堆中有效元素的下标从1开始
- length表示堆中元素的数量

## 大根堆解法
- 数组一共有n个数,那么维护一个大小为n的大顶堆
- poll() k次,poll()完k次之后,此时堆顶的元素就是当前数组中第k大的元素

```Java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int n = nums.length;
        MaxHeap hp = new MaxHeap(n);
        for(int i = 0; i < n; i++){
            hp.add(nums[i]);
        }
        
        for(int i = 0; i < k - 1; i++){
            hp.poll();
        }
        return hp.peek();
    }


    /*
    大顶堆:孩子节点比双亲都大
 */
    public class MaxHeap {
        int length; // 当前堆中的元素个数
        int[] heap; // 用于模拟堆的数组
        static final int DEFAULT_CAP = 10_000; // 堆的默认容量

        MaxHeap(){
            length = 0;
            heap = new int[DEFAULT_CAP];
        }

        MaxHeap(int n){
            length = 0;
            heap = new int[n + 1];
        }



        // 下滤:如果父亲节点小于两个孩子,则父亲节点应该下滤,直到堆底
        /**
         * 待下滤的元素的坐标:
         * @param idx
         */
        // 即:父元素不是父-子的最大者
        private void down(int idx){
            int maxIdx = idx; // 三个节点的最大值对应的点的下标

            int lChild = 2 * idx;
            int rChild = 2 * idx + 1;
            if(lChild <= length && heap[lChild] > heap[maxIdx]) {
                maxIdx = lChild;
            }
            if(rChild <= length && heap[rChild] > heap[maxIdx]) {
                maxIdx = rChild;
            }

            if(maxIdx != idx){
                swap(maxIdx, idx);
                down(maxIdx);
            }
        }

        // 上滤:如果孩子节点大于父亲节点,则应该上滤,直到堆顶
        // 当前节点,不是父亲-孩子中的较小者
        private void up(int idx){
            int minIdx= idx; // 三个节点的最小值对应的点的下标
            int parent = idx / 2;
            if(parent > 0 && heap[minIdx] > heap[parent]){
                minIdx = parent;
            }
            if(minIdx != idx){
                swap(minIdx, idx);
                up(minIdx);
            }

        }

        private void swap(int x, int y){
            int temp = heap[x];
            heap[x] = heap[y];
            heap[y] = temp;
        }

        public void add(int num){
            length++;
            heap[length] = num;
            up(length);
        }

        public void poll(){
            swap(1, length);
            length--;
            down(1);
        }
        
        public int peek(){
            return heap[1];
        }
    }

}
```

# 数据流中的中位数

## 对顶堆解法
使用对顶堆
- 规定:
    - 如果对顶堆中的元素为奇数,如2m + 1
    - 大顶堆的元素的数量为m + 1, 小顶堆的元素数量为m
    - 此时数据流中的中位数为大顶堆堆顶


当cnt为偶数例如2m
- 小顶堆存放[m + 1, 2m] → 堆顶[cnt / 2 + 1, cnt],共m个元素
- 大顶堆存放[1, m] → [1, cnt / 2]堆顶,共m个元素

添加一个数字num时
- 如果 <= 大顶堆堆顶 添加到大顶堆中
  - 添加完成前大顶堆共有<font color=red><b>m</b></font>个元素,小顶堆中共有<font color=red><b>m</b></font>个元素
  - 添加完成后大顶堆共有<font color=red><b>m + 1</b></font>个元素,小顶堆中共有<font color=red><b>m</b></font>个元素
- 如果 >= 小顶堆堆顶, 添加到小顶堆中
  - 添加完成前大顶堆共有<font color=red><b>m</b></font>个元素,小顶堆中共有<font color=red><b>m</b></font>个元素
  - 添加完成后大顶堆共有<font color=red><b>m</b></font>个元素,小顶堆中共有<font color=red><b>m + 1</b></font>个元素,不符合$size(maxHeap)>=size(minHeap)$
  - rebalence操作
    - num ← 小顶堆poll()
    - 大顶堆.add(num)
    - 此时堆中大顶堆共有<font color=red><b>m + 1</b></font>个元素,小顶堆中共有<font color=red><b>m</b></font>个元素
  

当cnt为奇数,例如2m + 1
- 小顶堆存放[m + 2, 2m + 1] → 堆顶[cnt / 2 + 2, cnt],共m个元素
- 大顶堆存放[1, m + 1] → [1, cnt / 2 + 1]堆顶,共m+1个元素

添加一个数字num时
- 如果 <= 大顶堆堆顶 添加到大顶堆中,此时大顶堆会有m + 2个元素
  - 添加完成前大顶堆共有<font color=red><b>m + 1</b></font>个元素,小顶堆中共有<font color=red><b>m</b></font>个元素
  - 添加完成后大顶堆共有<font color=red><b>m + 2</b></font>个元素,小顶堆中共有<font color=red><b>m</b></font>个元素,不符合$size(maxHeap)<=size(minHeap) + 1$的要求
  - rebalence操作
    - num ← 大顶堆poll()
    - 小顶堆.add(num)
    - 此时堆中大顶堆共有<font color=red><b>m + 1</b></font>个元素,小顶堆中共有<font color=red><b>m + 1</b></font>个元素

```Java
class MedianFinder {
    int cnt; // 数据流此时所有元素的数量
    PriorityQueue<Integer> maxHeap; // 大顶堆
    PriorityQueue<Integer> minHeap; // 小顶堆
    int addCount = 1;
    /** initialize your data structure here. */
    public MedianFinder() {
       
        cnt = 0;
        maxHeap = new PriorityQueue<>(new Comparator<Integer>(){
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2.compareTo(o1);
            }
        });
        minHeap = new PriorityQueue<>();
    }
    
    public void addNum(int num) {
        if(cnt == 0 || num <= maxHeap.peek()){
            // System.out.println("up: ===" + addCount + "===\t" + num + "\tmaxHeap:" + maxHeap.toString() + "minHeap:" + minHeap.toString());
            // 当前元素需要添加到大顶堆中
            maxHeap.add(num);
            // 校验是否需要重平衡
            rebalance(maxHeap.size(), minHeap.size());
            
        }else{
            // 当前元素需要添加到小顶堆中
            // 校验是否需要重平衡
             // System.out.println("down: ===" + addCount + "===\t" + num + "\tmaxHeap:" + maxHeap.toString() + "minHeap:" + minHeap.toString());
            minHeap.add(num);
            rebalance(maxHeap.size(), minHeap.size());
        }
        cnt++;
    }
    
    public double findMedian() {
        if((cnt & 1) == 1){
            return maxHeap.peek() * 1.0;
        }else{
            return (maxHeap.peek() + minHeap.peek()) * 0.5;
        }
    }
    
    // 大顶堆的元素个数,小顶堆的元素个数
    private void rebalance(int maxHeapSize, int minHeapSize){
        if(maxHeapSize == minHeapSize + 2){
            fromMaxHeapToMinHeap();
        }
        
        if(maxHeapSize + 1 == minHeapSize){
            fromMinHeapToMaxHeap();
        }
    }
    // 从小顶堆搬动到大顶堆
    private void fromMinHeapToMaxHeap(){
        int num = minHeap.poll();
        maxHeap.add(num);
    }
    // 从大顶堆搬动到小顶堆
    private void fromMaxHeapToMinHeap(){
        int num = maxHeap.poll();
        minHeap.add(num);
    }
}
```
## Points
- 一定要先**添加**,然后再**平衡**
- 例如```大顶堆{12},小顶堆{40}```,此时需要添加```{16}```
  - 若先平衡,再添加
   - 平衡结果:```{12,40},{}```,添加:```{12,40},{16}``` 
- 例如```小顶堆{12},小顶堆{40}```,此时需要添加```{16}```
  - 先添加```{12},{16,40}```
   - 再平衡```{12,16},{40}```


# 天际线问题

## 解法
- 扫描线问题
  - 通过扫描线,把多个矩形切分成一个个的<font color=red><b>长条</b></font>(将所有**竖边**延长,一个**长条**由两个**竖边**构成)
  - 对于每一个数条内的长方形,统计面积或者周长都非常容易


![20210807154313](https://i.loli.net/2021/08/07/oU2pWArVeXmvTKQ.png) 

![20210807154534](https://i.loli.net/2021/08/07/4vWpUNJKMwAqzm3.png)


**step1**:用竖线划分 → **取出所有的端点,然后按照横坐标排序**
![20210807154900](https://i.loli.net/2021/08/07/FUsKxhaPk5Ty3Dt.png)

![20210807155822](https://i.loli.net/2021/08/07/d2iPjwkQlr4Lt6x.png)


**step2**:用竖线划分,两段竖线内(一个**长条**)可能有**多段水平线**。两段竖线内(一个**长条**)中高度**最高的水平线**才能作为**长条内**的**天际线**。

![20210807160655](https://i.loli.net/2021/08/07/BK4szPtXA2Z8Vcr.png)

**实现step1**:将所有的入点和出点放到一个vector中,然后按照横坐标排序

![20210807161246](https://i.loli.net/2021/08/07/kdLhYACTjQ9UrGw.png)

**实现step2**:枚举所有相邻两点之间的长条高度,相邻两点间最高的高度即为天际线高度,使用某种数据结构进行维护
- 支持插入和删除操作
- 使用multiSet/PriorityQueue进行维护
  - <font color=blue>如果当前是左端点,表示当前长条中会加入一条边,会将**左端点对应的高度**加入multiSet/priorityQueue中</font>
  - <font color=blue>如果当前是右端点,表示当前长条中会删除一条边,会将**右端点对应的高度**从multiSet/priorityQueue中删除</font>

## 实现逻辑
(1)buildings → points

![20210808110236](https://i.loli.net/2021/08/08/qvuisU6WdXLIP3a.png)

(2)对points排序
- 按照横坐标x排序
- 横坐标x相同,再按照高度排序
  - **如果都是左端点,他们高度相同,那么高度高的排在前面**
  - **如果都是右端点,他们高度相同,那么高度低的排在前面**
  - **如果都是一个左端点,一个是右端点,他们坐标相同,那么左端点排在右端点前面**
  
(3) 初始化一个大根堆heap 和 二维的返回结果列表res
- prevH ← 0 上一个竖条的最大高度
- 将prevH 添加到堆中
- 遍历points,对于每一个point
  - x ← 当前点的横坐标, height ← 当前点的高度
  - 若当前点为**左**端点,将当前点的高度**添加**到堆中
  - 若当前点为**右**端点,将当前点的高度从堆中**删除**
  - curH ← heap.peek()
  - 如果curH == prevH,此时的point**不能作为天际线的起点**
  - 否则,此时的point可以作为天际线的起点
    - 将{$x_{point}$,$h_{point}$}添加到res中
## 一些特殊情况

分析排序规则的合理性:
- **如果都是左端点,他们高度相同,那么高度高的排在前面**
- **如果都是右端点,他们高度相同,那么高度低的排在前面**
- **如果都是一个左端点,一个是右端点,他们坐标相同,那么左端点排在右端点前面**
![20210807171331](https://i.loli.net/2021/08/07/OALdaXvqurYiUkb.png)
- (1)$p1(x0, p1.height),p2(x0,p2.height)$都为左端点
  - pq中已有元素```{}```   
  - 先遍历p1(较高),再遍历p2(较矮)
    - p1 ```{(x0, p1.height)}```
      - peek()(天际线) 为```{(x0, p1.height)}```
      - ret ```{(x0, p1.height)}```
    - p2, ```{(x0, p1.height),(x0, p2.height)}```
      - peek()(天际线) 为```{(x0, p1.height)}```,由于高度和上一轮迭代的高度相同,该段的height不会添加到返回结果中
      -  ret ```{(x0, p1.height)}```
  - 先遍历p2(较低),再遍历p1(较高) **×错误方案**
    - p2 ```{(x0, p2.height)}```
      - peek()(天际线) 为```{(x0, p2.height)}```
      - ret ```{(x0, p2.height)}```
    - p1, ```{(x0, p2.height),(x0, p1.height)}```
      - peek()(天际线) 为```{(x0, p1.height)}```
      -  ret ```{(x0, p2.height),(x0, p1.height)}```
      -  **生成了(x0, p2.height)这个错误的点**
  
- (2),(3)分析步骤同理

```Java
class Solution {
    int[][] points;
    int length;
    public List<List<Integer>> getSkyline(int[][] buildings) {
        length = buildings.length;
        points = new int[length * 2][2];
        for(int i = 0; i < length; i++){
            // 存放左端点的{横坐标,-高度}
            points[2 * i][0] = buildings[i][0];
            points[2 * i][1] = -buildings[i][2];
            
            // 存放右端点的{横坐标,高度}
            points[2 * i + 1][0] = buildings[i][1];
            points[2 * i + 1][1] = buildings[i][2];
        }
        // System.out.println(Arrays.deepToString(points)); 
        Arrays.sort(points, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2){
                if(o1[0] != o2[0]) return o1[0] - o2[0]; // 横坐标不同,按照横坐标升序排列
                return o1[1] - o2[1];
            }
        });
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->b - a);
        int prev = 0;
        pq.add(prev);
        List<List<Integer>> ret = new ArrayList<>();
        for(int i = 0; i < points.length; i++){
            // 将当前点对应的高度加入优先队列中
            int x = points[i][0];
            int h = points[i][1];
            if(h > 0){
                pq.remove(h);
            }else{
                pq.add(-h); // 左端点
            }
            int cur = pq.peek();
            if(cur != prev){
                // 当前横坐标,当前高度
                List<Integer> temp = new ArrayList<>();
                temp.add(x);
                temp.add(cur);
                prev = cur;
                ret.add(temp);
            }
            
        }
        return ret;
    }
    
}
```

## Points
- 实现比较规则
```Java
  Arrays.sort(points, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2){
                if(o1[0] != o2[0]) return o1[0] - o2[0]; // 横坐标不同,按照横坐标升序排列
                return o1[1] - o2[1];
            }
        });
```

- o1[0] != o2[0] return o1[0] - o2[0];
  - 先按照x排序
- return o1[1] - o2[1];
  - 当x相同
    - 如果都是左端点
      - buildings ```[3, 6, 2],[3, 5, 3]```
      - 左points`[3, -2]`,`[3, -3]`
      - <font color=red><b>排序要求:同为左端点,高度高的排在前面</b></font> $\rightarrow$ o1[1] - o2[1]符合要求
    - 如果都是右端点
      - buildings ```[1, 6, 2],[3, 6, 3]```
      - 左points`[6, 2]`,`[6, 3]`
      - <font color=red><b>排序要求:同为右端点,高度低的排在前面</b></font> $\rightarrow$ o1[1] - o2[1]符合要求
    - 如果一个左端点,一个右端点
      - buildings ```[1, 3, 2],[3, 6, 3]```
      - 左point`[3, -3]`,右point`[3, 2]`
      - <font color=red><b>横坐标相同,左端点排在右端点前面</b></font> $\rightarrow$ o1[1] - o2[1]符合要求
- 哨兵节点prev = 0，**为什么初始化大根堆之后,需要添加一个哨兵？**


![20210808180220](https://i.loli.net/2021/08/08/3vokRBhL7cSqETu.png)

## 附:微软笔试题
![20210808202128](https://i.loli.net/2021/08/08/iFKY9jX6mwsHdhQ.png)
- 思路
  - 左端点,不做操作
  - 右端点(x[i] < x[i-1]),统计结束砖块个数



![20210808201403](https://i.loli.net/2021/08/08/OF5Hb6uilGBzySq.png)


# 二叉树的最大路径和

```Java
// 某个节点的最大路径和
// 可能是该节点自身/该节点+左侧链/该节点+右侧链条/该节点+左侧链+右侧链条
// 向上返回: 当前节点 / 当前节点 + 左侧链 / 当前节点 + 右侧链
class Solution {
    int maxValue;
    public int maxPathSum(TreeNode root) {
        // maxValue = 0; // 全局的最大路径和
        maxValue = Integer.MIN_VALUE;
        recurse(root);
        return maxValue;
    }
    
    
    public int recurse(TreeNode root){
        if(root == null){ return 0; }
        int cur = root.val; // 包含当前节点的分支 当前节点 / 当前节点 + 左侧链 / 当前节点 + 右侧链
        int curMaxValue = root.val; // 包含当前节点的路径最大值  该节点自身/该节点+左侧链/该节点+右侧链条/该节点+左侧链+右侧链条
        int leftValue = 0;
        int rightValue = 0;
        if(root.left != null){
            leftValue = recurse(root.left);
            cur = Math.max(leftValue + root.val, cur);
            curMaxValue = Math.max(leftValue + root.val, curMaxValue);
        }
        if(root.right != null){
            rightValue = recurse(root.right);
            cur = Math.max(rightValue + root.val, cur);
            curMaxValue = Math.max(rightValue + root.val, curMaxValue);
        }
        if(root.left != null && root.right != null){
            curMaxValue = Math.max(leftValue + root.val + rightValue, curMaxValue);
        }
//         if(root.val == 11){
//            System.out.println("left" + leftValue + "--" + "right" + rightValue); 
//         }
        
        maxValue = Math.max(maxValue, curMaxValue);
        return cur;
    }
}
```

## Points
- 二叉树题目,注意测试用例,节点值可能 < 0,所以maxValue要设置为Integer.MIN_VALUE
  - ```[-3]```
- cur 取得是```root.val, root.val + leftValue, root.val + rightValue```中的最大值
  - ```cur ← root.val```
  - ```cur ← max(root.val + leftValue, cur)```
  - ```cur ← max(root.val + rightValue, cur)```

# 二叉树中的列表
- 稍微晚一点整理note
```Java
// 从每一个节点开始,可以自己去匹配,也可以匹配节点的某一个位置
class Solution {
    public boolean isSubPath(ListNode head, TreeNode root) {
        if(head != null && root == null) return false;
        return isSubPath(head, root.left) || solve(head, root) || isSubPath(head, root.right);
    }
    // dfs匹配方法
    private boolean solve(ListNode head, TreeNode node){
        if(node == null && head != null) return false; 
        // node == null head == null
        // node != null head == null
        // node != null head != null
        if(head == null) return true;
        // node != null head != null
        if(head.val != node.val) return false;
        return solve(head.next, node.left) || solve(head.next, node.right);
    }
}
```


# 解数独
## 回溯解法
**标记**
```Java
row[9][9] 1~9行,数字1~9是否出现过
col[9][9] 1~9列,数字1~9是否出现过
ceil[3][3][9] 3*3个小单元格,数字1~9是否出现过
```

遍历给的棋盘board,将现有数字更新到数组中
```Java
 for(int i = 0; i < board.length; i++){
            for(int j = 0; j < board.length; j++){
                if(board[i][j] != '.'){
                    // 此时为数字
                    int num = board[i][j] - '1';
                    // System.out.println(num);
                    row[i][num] = true;
                    col[j][num] = true;
                    ceil[i / 3][j / 3][num] = true;
                }
            }
        }
```

回溯,从左上角开始 backtrack(board, 0, 0)
- 该回溯是**自底向上**的递归,棋盘能否填充完毕的结果backtrack(board, 0, 0)依赖于叶子节点的结果

![20210815103750](https://i.loli.net/2021/08/15/IXMGDp4O1nWLo8U.png)

- 为了方便,按照如图方式进行遍历

![20210815100700](https://i.loli.net/2021/08/15/cepkaYfP35l4h7z.png)
```Java
if(y == 9) y = 0; x++  表明到达下一行
if(x == 9) return true; 表明整个棋盘已经遍历完毕
```

- 如果当前位子上已经存在数字,则可以继续遍历下一个位子
```Java
if(board[i][j] != '.'){
    return backtrack(board, i, j + 1);
}
```
- 枚举
  - **如果使用某个数字填充当前位置后,未来结果(叶子节点)能够填充棋盘完毕,则直接返回即可**
    - 否则,重置填充标志,进行回溯
  - 当穷尽了所有枚举方案,还没有正确的结果,返回False
```Java
class Solution {
    boolean[][] row;
    boolean[][] col;
    boolean[][][] ceil;
    public void solveSudoku(char[][] board) {
        row = new boolean[9][9];
        col = new boolean[9][9];
        ceil = new boolean[3][3][9];
        
        for(int i = 0; i < board.length; i++){
            for(int j = 0; j < board.length; j++){
                if(board[i][j] != '.'){
                    // 此时为数字
                    int num = board[i][j] - '1';
                    // System.out.println(num);
                    row[i][num] = true;
                    col[j][num] = true;
                    ceil[i / 3][j / 3][num] = true;
                }
            }
        }
                                                                                                    
       // System.out.println(Arrays.deepToString(ceil));
        // System.out.println(ceil[1][2][4]);
        backtrack(board, 0, 0);
        
        
    }
    
    public boolean backtrack(char[][] board, int x, int y){
        if(y == 9) {
            x++;
            y = 0;
        }
        if(x == 9) return true;
        // 如果当前是数字,返回下一个位置的结果
        if(board[x][y] != '.'){
            return backtrack(board, x, y + 1);
        }
        
        for(int num = 0; num < 9; num ++){
            if(!row[x][num] && !col[y][num] && !ceil[x / 3][y / 3][num]){
                row[x][num] = true;
                col[y][num] = true;
                ceil[x / 3][y / 3][num] = true;
                board[x][y] = (char)('1' + num); 
                boolean result = backtrack(board, x, y + 1);
                if(result) return result;
                // 递归方案不可行,则回溯
                board[x][y] = '.';
                row[x][num] = false;
                col[y][num] = false;
                ceil[x / 3][y / 3][num] = false;
            }
        }
        // 穷尽了所有填写数字的可能性,都没办法找到方案
        return false;
    }
}
```

# 根节点到叶节点数字之和
```Java
class Solution {
    int totalSum;
    public int sumNumbers(TreeNode root) {
        totalSum = 0;
        dfs(root, 0);
        return totalSum;
    }
    
    public void dfs(TreeNode node, int value){
        if(node.left == null && node.right == null){
            int curValue = node.val + value * 10;
            totalSum += curValue;
            return;
        }
        
        int curValue = node.val + value * 10;
        if(node.left != null) {
            dfs(node.left, curValue);
        }
        if(node.right != null) {
            dfs(node.right, curValue);
        }
    }
}
```

# 基本计算器
## 解法
- 入参是一个计算式字符串$S$
  - 将字符串$S$转化成字符数组$chars$
- 参数设置
  - 初始化一个操作符栈$ops$,一个操作数栈$nums$
  - nums中<font color=red><b>压入0,用于防范"-1 +2"这种用例</b></font>
- 实现逻辑
  - $for \quad i \quad  chars$,对于其中某个字符$curChar$
    - (1)若$curChar$为" ",则继续下一轮迭代
    - (2)若为数字```Character.isDigit(curChar)```,调用**readNum历程**
        - 累加和,非数字字符下标$nextI$ ← readNum(i)
        - 累加和入操作数栈
        - i ← nextI - 1
    - (3)若为'(',则压入操作符栈
    - (4)若为')',则表示可以匹配括号里面的内容$(\dots)$
      - 当操作符栈栈顶不为'(',循环调用**compute历程**
        - num ← compute()
        - 将num压栈
    - (5)否则,(这种情况对应操作符)
      - 先计算完优先级低的运算内容: 此时可以进行运算,一直到栈顶非'('为止
        - 比如说```(1 + 2 - 3)```,当遍历到```-```时,可以将```1 + 2```计算出来
        - num ← compute()
        - 将num压栈
      - 将当前运算符压入运算符栈
  - 迭代结束, 若运算符栈非空,继续运算
   
- int[] readNum(int start)
  - 从start位置出发,一直遍历抵达第一个非数字的字符为止,返回$int[] \quad \{累加和,第一个非数字的字符的下标\}$
- int compute()
  - a ← 操作数弹栈
  - b ← 操作数弹栈
  - op ← 运算符栈弹栈
  - 根据op,计算b op a,返回
```Java
class Solution {
    Stack<Integer> nums;
    Stack<Character> ops;
    char[] chars;
   
    public int calculate(String s) {
        nums = new Stack<>();
        ops = new Stack<>();
        chars = s.toCharArray();
        nums.push(0);
        // System.out.println(Arrays.toString(readNum(1)));
        for(int i = 0; i < chars.length; i++){
            if(chars[i] == ' ') continue;// 空格字符
            else if(chars[i] == '(') ops.push(chars[i]);
            else if(chars[i] == ')'){
                while(!ops.isEmpty() && ops.peek() != '('){
                    int num = compute();
                    nums.push(num);
                }
                ops.pop();
            }
            else if(Character.isDigit(chars[i])){
                int[] readResult = readNum(i);
                int num = readResult[0];
                nums.push(num);
                int nextI = readResult[1];
                i = nextI - 1;
                // System.out.println("i:" + i + "--" + "num:" + num);
            }else{ // 两种操作符
                while(!ops.isEmpty() && ops.peek() != '('){
                    int num = compute();
                    nums.push(num);
                }
                ops.push(chars[i]);
            }
        }
        // System.out.println(ops.toString());
        while(!ops.isEmpty() && ops.peek() != '('){
            int num = compute();
            nums.push(num);
        }
        return nums.peek();
        
    }
    
    public int[] readNum(int begin){
        // begin为readNumber的起始位置
        int base = 0;
        int end = begin;
        for(int i = begin; i < chars.length; i++){
            if(Character.isDigit(chars[i])){
                base *= 10;
                base += chars[i] - '0';
               // System.out.println("base:" + base + "i:" + i);
            }else{
                end = i;
                return new int[] {base, end};
            }
        }
        
        return new int[] {base, chars.length};
    }
    
    // compute
    // 操作数栈弹栈,计算结果并返回
    public int compute(){
        int a = nums.pop();
        int b = nums.pop();
        char op = ops.pop();
        if(op == '+') return b + a;
        else return b - a;
    }
}
```

# 缺失的第一个正数

![20210815184101](https://i.loli.net/2021/08/15/lMbPv2HEOe7K3an.png)
思路


- (解法2)原地hash
  - **长度为n的数组,最多放有序的整数范围为$1 \rightarrow n$**
  - 遍历nums,当$nums[i]!=nums[nums[i]-1]$时(即:4不在nums[3]位子上时,交换4和nums[3]的元素值)
  - 再次遍历nums,当发现$nums[i]!=i+1$,返回$i+1$

- 错误实现
```Java
class Solution {
    int[] nums;
    
    public int firstMissingPositive(int[] nums) {
        this.nums = nums;
        int n = nums.length; // nums中如果为[1,n]则缺失的第一个数字为n+1
        
        for(int i = 0; i < n; i++){
            // 校验nums[i],只有nums[i] > 0 && nums[i] < n,nums[i]才能作为下标
            if(nums[i] <= 0 || nums[i] >= n) continue;
            // 交换
            // eg.对于[-1, 1, 3, 4] -- [[1],2,[3],[4]]
            // eg.对于[2,7,1,3,5,9] -- [[1],[2],[3],4,[5],6]
            // 合法的nums[i]对应的下标应该为nums[i] - 1
            int idx = nums[i] - 1;
            if(nums[idx] != nums[i]) swap(idx, i);
        }
        for(int i = 0; i < n; i++){
            if(nums[i] != i + 1){
                return i + 1;
            }
        }
        
        return n + 1;
    }
    
    private void swap(int x, int y){
        int temp = nums[x];
        nums[x] = nums[y];
        nums[y] = temp;
    }
}
```

- 错误原因可以看以下用例
```Java
[-1,4,2,1,9,10]
```

![20210815190803](https://i.loli.net/2021/08/15/dsR1uKaktGJ2nrL.png)

![20210815191211](https://i.loli.net/2021/08/15/FlqaMtzHZ8sJkhr.png)

- 改进版,但是这一版还是有问题
```Java
class Solution {
    int[] nums;
    
    public int firstMissingPositive(int[] nums) {
        this.nums = nums;
        int n = nums.length; // nums中如果为[1,n]则缺失的第一个数字为n+1
        
        for(int i = 0; i < n; i++){
            while(true){
                // 校验nums[i],只有nums[i] > 0 && nums[i] < n,nums[i]才能作为下标
                if(nums[i] <= 0 || nums[i] >= n) break;
                if(nums[i] == i + 1) break;
                // 交换
                // eg.对于[-1, 1, 3, 4] -- [[1],2,[3],[4]]
                // eg.对于[2,7,1,3,5,9] -- [[1],[2],[3],4,[5],6]
                // 合法的nums[i]对应的下标应该为nums[i] - 1
                int idx = nums[i] - 1;
                // System.out.println("i:" + i + "\tnumber:"+ nums[i] + "==" + Arrays.toString(nums));
                if(nums[idx] != nums[i]) {
                    swap(idx, i);
                }
                // System.out.println("i:" + i + "\tnumber:"+ nums[i] + "==" + Arrays.toString(nums));
            }
        }
        // System.out.println(Arrays.toString(nums));
        for(int i = 0; i < n; i++){
            if(nums[i] != i + 1){
                return i + 1;
            }
        }
        
        return n + 1;
    }
    
    private void swap(int x, int y){
        int temp = nums[x];
        nums[x] = nums[y];
        nums[y] = temp;
    }
}
```
- 错误原因可以看以下用例
```Java
[1,1]
```

- 错误原因在于,当遍历到nums[1] == 1,时候,发现nums[0]位置上的元素为1,这个时候不会进行交换(**没有考虑数组有重复元素**)

```Java
class Solution {
    int[] nums;
    
    public int firstMissingPositive(int[] nums) {
        this.nums = nums;
        int n = nums.length; // nums中如果为[1,n]则缺失的第一个数字为n+1
        
        for(int i = 0; i < n; i++){
            while(true){
                // 校验nums[i],只有nums[i] > 0 && nums[i] < n,nums[i]才能作为下标
                if(nums[i] <= 0 || nums[i] >= n) break;
                if(nums[i] == i + 1) break;
                // 交换
                // eg.对于[-1, 1, 3, 4] -- [[1],2,[3],[4]]
                // eg.对于[2,7,1,3,5,9] -- [[1],[2],[3],4,[5],6]
                // 合法的nums[i]对应的下标应该为nums[i] - 1
                int idx = nums[i] - 1;
                // System.out.println("i:" + i + "\tnumber:"+ nums[i] + "==" + Arrays.toString(nums));
                if(nums[idx] != nums[i]) {
                    swap(idx, i);
                }else{ // 出现重复元素
                    break;
                }
                // System.out.println("i:" + i + "\tnumber:"+ nums[i] + "==" + Arrays.toString(nums));
            }
        }
        // System.out.println(Arrays.toString(nums));
        for(int i = 0; i < n; i++){
            if(nums[i] != i + 1){
                return i + 1;
            }
        }
        
        return n + 1;
    }
    
    private void swap(int x, int y){
        int temp = nums[x];
        nums[x] = nums[y];
        nums[y] = temp;
    }
}
```


# 和为K的子数组
```Java
class Solution {
    Map<Integer, Integer> map;
    int[] preSum;
    int length;
    int count;
    public int subarraySum(int[] nums, int k) {
        map = new HashMap<>();
        length = nums.length;
        count = 0;
        preSum = new int[length + 1];
        map.put(0, 1);
        for(int i = 0; i < nums.length; i++){
            preSum[i + 1] = preSum[i] + nums[i];
            // 之前的某些前缀和 preSum[l1], preSUm[l2],...
            // 如果sum(l1 to i) == k, sum(l2 t0 i) == k
            // preSum[i + 1] - preSum[l1] == k
            // preSum[i + 1] - preSum[l2] == k
            // preSum[l1] / preSum[l2] == preSum[i + 1] - k
            if(map.containsKey(preSum[i + 1] - k)){
                count += map.get(preSum[i + 1] - k);
            }
            map.put(preSum[i + 1], map.getOrDefault(preSum[i + 1], 0) + 1);
            // System.out.println("i: " + i + "map: " + map.toString());
        }
        return count;
    }
}
```

## Points
- (1)记录数组前缀和的map中必须放入```<preSum[0],1>```(key == 0, value == 1),即表示前缀和为0的次数为1
- (2)可以省略前缀和数组,直接用map
- (3)**原理**
  - 如果$nums[l1] + nums[l1+1] + ... + nums[i] == k$
    - 即$preSum[i + 1] - preSum[l1] == k \rightarrow preSum[l1] == preSum[i+1] - k$
  - 如果$nums[l2] + nums[l2+1] + ... + nums[i] == k$
    - 即$preSum[i + 1] - preSum[l2] == k \rightarrow preSum[l2] == preSum[i+1] - k$
  - 则map中有2个值为$preSum[i+1] - k$的前缀和
# 求最短通路值
- 二分 + dfs
```Java
public class Solution {
    int[][] matrix;
    boolean[][] visited;
    int m;
    int n;
    int shortest;
    final static int[][] pos = new int[][] {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
    public static void main(String[] args) {
        Solution solution = new Solution();
        solution.method();
    }

    public int method(){
        matrix = new int[][]{
                {1, 0, 1, 1, 1},
                {1, 0, 1, 0, 1},
                {1, 1, 1, 0, 1},
                {0, 0, 0, 0, 1},
        };

        m = matrix.length;
        n = matrix[0].length;
        // 长m × n的矩阵,最多走m × n步,反复横跳哈哈哈
        int right = m * n + 2;
        int left = 0;
        while(left < right){
            int mid = left + (right - left) / 2;
            visited = new boolean[m][n];
            visited[0][0] = true;
            if(dfs(0, 0, mid, 1)) right = mid;
            else left = mid + 1;
        }

        System.out.println("left = " + left);
        return 1;
    }

    // target是希望实现的最短路径
    // path是实际上现在的路径长度
    public boolean dfs(int x, int y, int target, int path){
        if(path > target) return false;
        // path <= target
        if(x == m - 1 && y == n - 1 && matrix[x][y] == 1){
            return true;
        }

        for(int p = 0; p< 4; p++){
            int[] po = pos[p];
            int nextX = x + po[0];
            int nextY = y + po[1];
            if(0 <= nextX && nextX < m && 0 <= nextY && nextY < n && matrix[nextX][nextY] == 1){
                if(!visited[nextX][nextY]){
                    visited[nextX][nextY] = true;
                    if(dfs(nextX, nextY, target, path + 1)) return true;
                }
            }
        }
        return false;
    }

}
```
# 俄罗斯信封套娃
## dp解法(略)
## 二分优化
- 本题是**最长上升子序列**的变形题

## **最长上升子序列**二分解法
数组为nums [10,9,2,5,3,7,101,18],求nums的最长上升子序列
  - 建立辅助数组assists, $[left, right]$构成assists的搜索区间,**assists递增、有序**
  - 遍历nums,下标i from 0 to nums.length - 1
    - 当i == 0时,assist[0] == nums[0]
    - 当i > 0时,对于每一个nums[i],在assists中查找到第一个<b>>=nums[i]</b>的元素,对应下标的查找结果为**left**
      - **注意:** 若nums[0]为1,nums[1]为2,此时assists中有效填充元素为assists[0],则在遍历到**i==1**时,需要使得assists中存在<b>>=nums[i]</b>的元素
      - 为了实现assist中始终存在<b>>=nums[i]</b>的元素,assists一开始就可以使用+INF填充
      - 搜索区间$[left, right]$为[0,有效元素个数]

![](https://gitee.com/fluffyball/blogimage/raw/master/images/localPC/202108232130559.png)


![](https://gitee.com/fluffyball/blogimage/raw/master/images/localPC/202108232202486.png)

- 二分
  - 在$[left, right]$中查找<b>第一个>=nums[i]</b>的下标(或者说最靠左的),
  - $mid \leftarrow left + (right - left)/2$
  - 如果assists[mid] >= nums[i] 
    - (1)mid肯定符合要求
    - (2)希望mid尽可能小 → right = mid
  - 否则
    - left = mind + 1
- 若 $left(查找结果) == right$,表明此时assists的长度可以向右延长一个单位
  - assists[right] = nums[i]
  - right++
  - **更新最长上升子序列长度**

## 解法
- 信封A,B要实现套娃
  - $w_A < w_B$
  - $h_A < h_B$
- 首先,可以按照$w$进行排序,保证$x <= y$时,有$w_x <= w_y$
- 然后以$h$为维度,选出最长上升子序列
- **注意**
  - 对于$[1,1],[2,3],[2,5],[3,4],[4,7]$
  - 如果**单纯以h为维度**,$[2,3],[2,5]$可以构成上升子序列
  - 为了**避免在等宽度时,高度递增的信封构成上升子序列**
  - **同宽度下,高度降序**
    - eg.
    - $[1,1],[2,3],[2,5],[3,4],[4,7]$
    - 以h作为判断标准,$[1,1],[2,3],[2,5],[4,7]$可以作为最长上升子序列的方案之一
    - 等w情况下h降序: $[1,1],[2,5],[2,3],[3,4],[4,7]$
    - 以h作为判断标准,$[1,1],[2,3],[3，4],[4,7]$可以作为唯一的最长上升子序列的方案

```Java
class Solution {
    int length;
    int[] assists; 
    public int maxEnvelopes(int[][] ens) {
        length = ens.length;
        Arrays.sort(ens, (o1, o2) -> {
            if(o1[0] != o2[0]) return o1[0] - o2[0];
            else{
                return o2[1] - o1[1];
            }
        });
        // System.out.println(Arrays.deepToString(ens));
        assists = new int[length + 1];
        Arrays.fill(assists, Integer.MAX_VALUE);
        int maxLength = 1;
        assists[0] = ens[0][1];
        int leftBound = 0;
        int rightBound = 1;
        for(int i = 1; i < ens.length; i++){
            int height = ens[i][1];
            // 向左边查找,最后一个 >= height的元素
            int left = leftBound;
            int right = rightBound;
            while(left < right){
                int mid = left + (right - left) / 2;
                if(assists[mid] >= height){ 
                    right = mid;
                }else{ // assists[mid] < height
                    left = mid + 1;
                }
            }
            if(left == rightBound){
                assists[rightBound] = height;
                rightBound++;
                maxLength = Math.max(maxLength, rightBound);
            }else{ // left < rightBound
                assists[left] = height;
            } 
            // System.out.println("i: " + i + "--" + Arrays.toString(assists));
        }
        return maxLength;
    }
}
```

# 括号的分数
## 思路
- 声明一个总的累计值score
- (1)每碰到一个左括号```(```,入栈$0$
- (2)每碰到一个右括号```)```
  - 此时表明至少有一个括号配对完成,声明变量$curScore$对应局部的累计分值
  - 如果是```(  |)|```,当前栈顶数字为$0$,```()```对应数字```1```
    - 弹出栈顶top,加1,
    - curScore = top
  - 如果是```(()  |)|```,当前栈顶数字为$a$,```(() |)|```对应数字```2 * a```
     - 弹出栈顶top,*2,
     - curScore = top
   - 如果此时栈中不存在元素,即对应例如```()|(())```遍历到竖线的位置
     - 可以将当前匹配括号对应的局部分值curScore累加到整体分值$score$中
   - 否则,如果此时栈中还有>=1个元素,表明当前匹配完成的括号是被**嵌套**的括号,需要将当前栈顶(**被嵌套括号外层括号**)**累加**内层被**嵌套**括号的值
     - 累加操作
       - top ← 弹出当前栈顶
       - top += curScore
       - 将top压入栈中

```Java
class Solution {
    char[] chars;
    Stack<Integer> stk;
    public int scoreOfParentheses(String s) {
        chars = s.toCharArray();
        stk = new Stack<>();
        
        int score = 0;
        for(int i = 0; i < chars.length; i++){
            if(chars[i] == '(') stk.push(0);
            else{
                int curScore = 0; // 当前)构成的区域
                int top = stk.pop();
                if(top == 0){
                    curScore = (top + 1);   
                }else{
                    curScore = top * 2;
                }
                // 如果栈非空,修改top
                if(!stk.isEmpty()){
                    top = stk.pop();
                    top += curScore;
                    stk.push(top);
                }else{
                    score += curScore;
                }
                // System.out.println(stk.toString());
            }
        }
        return score;
    } 
    
}

```

# K连续位的最小翻转次数
```Java
class Solution {
    int n; // 总元素个数
    int[] diff; // 差分数组
    public int minKBitFlips(int[] nums, int k) {
        n = nums.length;
        diff = new int[n + 1];
        int ops = 0;
        int cnt = 0;
        for(int i = 0; i <= nums.length - k; i++){
            ops += diff[i];
            if(ops % 2 == 1){
                // 已有翻转
                nums[i] = Math.abs(1 - nums[i]);
            }
            if(nums[i] == 0){
                int left = i;
                int right = i + k - 1;
                
                diff[left] ++;
                diff[right + 1] --;
                
                ops += 1; 
                cnt++;
                nums[i] = 1;
            }
        }
        for(int i = nums.length - k + 1; i < nums.length; i++){
            ops += diff[i];
            if(ops % 2 == 1){
                nums[i] = Math.abs(1 - nums[i]);
            }
            if(nums[i] == 0) return -1;
        }
        return cnt;
    }
}
```  
## Notes:
![](https://gitee.com/fluffyball/blogimage/raw/master/images/localPC/202108272050437.png)
在完成翻转后,记得**ops++**,因为**ops**表示的含义是翻转次数,是一个**累积值**
- 之前的累积值是**ops**,位置i上现有的累积值是**diff[i]**
  - **ops += diff[i]**
  - 如果发现当前nums[i]需要翻转(ops % 2 == 1)
    - 翻转nums[i]
  - 如果发现翻转了之后nums[i]==0,翻转次数+1
    - diff[left]++;($left == i$)
    - diff[right + 1]--;
    - **由于diff[left]++,所以红框中ops++**